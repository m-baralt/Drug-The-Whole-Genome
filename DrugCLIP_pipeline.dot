digraph DrugCLIP {
  rankdir=LR;
  fontsize=12;

  // Global node defaults
  node [shape=box, style=filled, fillcolor="#ffffff", color="#000000"];

  // Top-level nodes (with clickable anchors matching the markdown)
  A [label="retrieval.sh", URL="#retrievalsh"];
  B [label="retrieval.py", URL="#retrievalpy"];
  C [label="task=drugclip", shape=diamond, URL="#tasksetup"];
  D [label="drugclip.py", URL="#drugclippy"];
  E [label="DrugCLIP class", shape=hexagon, URL="#drugclipclass"];

  // model_build cluster
  subgraph cluster_model_build {
    label="model_build";
    style=filled;
    color="#f8f8f8";
    node [shape=box, fillcolor="#ffffff"];
    F [label="build_model", URL="#buildmodel"];
    G [label="arch=drugclip", shape=diamond, URL="#archdrugclip"];
    H [label="drugclip.py", URL="#drugclippy2"];
    I [label="BindingAffinityModel", shape=component, URL="#bindingaffinity"];
    J [label="build_model", URL="#buildmodel2"];
  }

  // model_build2 cluster
  subgraph cluster_model_build2 {
    label="model_build2";
    style=filled;
    color="#f8f8f8";
    F1 [label="retrieval_multi_folds"];
  }

  // multi_folds_loop cluster (dashed to indicate loop)
  subgraph cluster_multi_folds_loop {
    label="multi_folds_loop";
    style=dashed;
    color="#dddddd";
    G1 [label="use-cache", shape=diamond];
    F_false [label="", style=invis];

    H1 [label="load_mols_dataset"];
    I1 [label="Prepare Input"];
    J1 [label="Distance + Edge fusion"];
    K1 [label="Transformer Encoder"];
    L1 [label="Prepare Output"];
    M1 [label="Save embeddings"];

    H2 [label="load_pockets_dataset"];
    I2 [label="Prepare Input"];
    J2 [label="Distance + Edge fusion"];
    K2 [label="Transformer Encoder"];
    L2 [label="Prepare Output"];

    Z [label="Load embeddings"];
  }

  // matrix & post clusters
  subgraph cluster_matrix {
    label="matrix";
    style=filled;
    color="#f8f8f8";
    N [label="Matrix Multiplication"];
  }

  subgraph cluster_post {
    label="post";
    style=filled;
    color="#f8f8f8";
    O [label="Multi-folds mean"];
    P [label="Adjusted robust z-score"];
    Q [label="Max score"];
  }

  // Edges (mirroring the mermaid flow)
  A -> B;
  B -> C;
  C -> D;
  D -> E;
  E -> F;
  E -> F1;
  F1 -> G1;

  G1 -> F_false [label="False", style=solid];
  F_false -> H1;

  H1 -> I1 [label="DataLoader"];
  I1 -> J1;
  J1 -> K1;
  K1 -> L1;
  L1 -> M1;

  F_false -> H2;
  H2 -> I2 [label="DataLoader"];
  I2 -> J2;
  J2 -> K2;
  K2 -> L2;

  G1 -> Z [label="True"];

  L1 -> N;
  L2 -> N;

  N -> O;
  O -> P;
  P -> Q;

  // cosmetic: use invisible nodes/classes where mermaid used invisible
  F_false [width=0, height=0];

  // rank constraints for layout hints
  { rank = same; A; B; C; D; E }
  { rank = same; N; }
}
